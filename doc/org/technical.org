#+SETUPFILE: level-0.org
#+TITLE: Technical information
* Technical information
  Metaphor is written in Python making use of third party pure Python
  libraries. It has been tested with Python 2.6.

** Code organization
   The metaphor repository contains the following directories:
    - =metaphor= -- the source code for the Metaphor system
    - =contexts= -- a number of useful contexts
    - =doc= -- documentation for Metaphor
    - =examples= -- a number of systems and scripts to create images
    - =test= -- unit tests (incomplete as of v3.0)
    - =metaphor.py= -- the starter script

   The =metaphor/= directory contains the following subdirectory
    - =core= -- the code for the core system
    - =lib= -- third party libraries used by Metaphor
    - =ui= -- different user front-ends

   Each of the core/ files contains code relevant to a particular part of
   Metaphor. In particular:
    - =parser.py= -- contains functions to autogenerate the parser using PLY
    - =system.py= -- contains the core code components including a visitor over the
      AST, a class representing an Lsystem and a class for an interaction Environment
    - =context.py= -- contains a handler class for contexts which performs loading,
      validation and interaction

** Contexts
   Contexts are Python classes that implement visualization (or other rendering)
   environments. Each context must have at least the following:
    - A .py file with the same name as the context
    - A class in the .py file with the same name as the file and context
    - A =wrapup()= method in the class

   When a context is loaded into Metaphor a new instance of the context class
   is created. No arguments are passed into the constructor. The string
   generated by the L-system is translated into method calls (with arguments) on
   the created context object. If the context object does not implement a
   particular method, the rendering is aborted. Once the string is finished
   Metaphor calls a =wrapup()= method on the object. I suggest that the
   =wrapup()= method implement saving of the final output and any cleanup.

* Developer information
  Before starting development on Metaphor, please take some time to read through
  the code and get familiar with the basic structure of the layout (See code
  organization above). The rest of this section focuses on some guidelines you
  should follow when writing code for Metaphor.

** General coding practices
   Please follow standard Python coding practices. In particular, read [[http://www.python.org/dev/peps/pep-0008/][PEP 8]] for
   guidelines on naming and indentation conventions. If you are adding classes
   and functions, try to group them together into files intelligently. 

   Use comments when necessary, try not to overdo it. Classes and methods should
   have API documentation in the form of docstrings according to [[http://epydoc.sourceforge.net/][Epydoc]]. It's
   similar to Javadoc. It's probably a good idea to write the docstrings as
   you're writing code instead of waiting till later. Again, don't overdo it.

** The Metaphor API
   The Metaphor API is designed to support multiple user interfaces. The
   text-based L-System decalaration is only one of the possible ways to create
   Lsystems and interact with them. The Metaphor API is mostly implemented via 2
   classes: =System= and =Environment=. There are supporting classes for
   representing Symbols, Productions and Rules. 

   System and it's supporting classes should be used for expressing the actual
   Lsystems. Interfaces should create instances of these classes and add them to
   an Environment. The supporting classes are essentially data containers and do
   not contain any methods. The System class contains methods for adding Rules
   and Render directives. It also contains methods for generating and rendering
   strings.

   The Environment class is meant to be the main API for interfaces. It can
   create Lsystems from text declarations and can load contexts. It also
   provides methods for generating strings and rendering. Environment should be
   extended to provide a debug environment including inspection and editing of
   strings and render instructions. As of v0.2 much of this functionality is
   missing.

** Unit tests
   Writing unit tests suck. There, I said it. Luckily I made some of the
   decisions for you and provide a test setup that will hopefully make it easier
   for you to write tests with minimum pain. Here we go.

*** Running tests
    Metaphor tests use the built-in unittest framework, but makes use of the
    nosetest framework to make it easier to run tests. You can run =nosetests=
    from the command line in the metaphor top-level directory. Or you can run
    the =metaphor.py= script with the =-t= or =--test= option. Using the command line
    lets you use all of nosetests options while the script just provides a basic
    run. See the excellent [[http://somethingaboutorange.com/mrl/projects/nose/0.11.2/index.html][nose]] documentation for all the running options.

*** Writing tests
    There are a few simple rules you should follow to write unit tests for
    Metaphor:
     1. All tests go in the =test/= directory
     2. If you're testing a file, create a test file. If you're testing a
        function, create a test function. If you're testing a class create a
        test class. Prefix files, functions and methods with =test_=. Prefix classes with
        =Test=. Use meaningful suffixes to test different paths through the same
        method or function. Be smart and keep names small.
     3. Read the [[http://docs.python.org/library/unittest.html][unittest documentation]]. Now.
     4. Look at some of the existing tests to get a feel for what your tests
        should be like.
     5. If you're adding tests for contexts, be sure that your names do not
        conflict with other contexts. Don't overwrite other peoples test files.
