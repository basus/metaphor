"""Classes required to implement the semantics of the Metaphor system.
   Some of these work on the ASTs generated by the parser. """

import random

import error

class Builder:
    '''Traverses an abstract syntax tree and builds the grammars described '''
    def __init__(self, node=None):
        self.__node = node
        self.grammars = {}
    
    def build_all(self):
        '''Directly traverses the entire tree and builds up the grammar objects'''
        grammars = []
        for grammar in self.__node.grammarlist:
            self.__node = grammar
            grammars.append(self.build_grammar())
        return grammars

    def build_grammar(self):
        '''Builds the grammar object corresponding to the current node.'''
        name = self.__node.name
        base = self.build_base()
        axiom = self.build_axiom()
        productions = self.build_productions()
        maps = self.build_maps()
        assigns = self.build_assigns()
        return Grammar(name, base, axiom, productions, maps, assigns)


    def build_base(self):
        '''Returns the base name from the AST '''
        try:
            return self.__node.base.base
        except:
            return None

    def build_axiom(self):
        '''Returns the axiom from the AST '''
        try:
            return self.__node.axiom.axiom
        except:
            return None

    def build_productions(self):
        '''Returns a dictionary of terminal --> productions'''
        prod_dict = {}
        for production in self.__node.productionlist:
            if not production.nonterm in prod_dict.keys():
                prod_dict[production.nonterm] = {}
            prod_dict[production.nonterm][production.param] = production.productions
        return prod_dict

    def build_maps(self):
        '''Returns a dictionary of symbol --> context function '''
        map_dict = {}
        for elementmap in self.__node.maplist:
            map_dict[elementmap.element] = elementmap.repr
        return map_dict

    def build_assigns(self):
        '''Returns dictionary of variables --> values '''
        assign_dict = {}
        for assign in self.__node.assignlist:
            assign_dict[assign.param] = assign.value
        return assign_dict

class Grammar:
    ''' A class to represent Grammars'''
    
    def __init__(self, name, base, axiom, productions, maps, assigns):
        self.name = name
        self.base = base
        self.axiom = axiom
        self.productions = productions
        self.maps = maps
        self.assigns = assigns            

    def transform(self, token):
        '''Takes in a token and calculates an appropriate replacement string based
        on analyzing the productions dictionaries'''

        #Get reference to expansion dictionary and initialize probability holder
        followers = self.productions[token]
        probabilities = {}

        #Check if unparameterized
        if '_' in followers:
               return followers['_']

        #Sum ratios
        total = 0
        for each in followers.keys():
            total += self.assigns[each]

        #Generate probabilities
        for each in followers.keys():
            probabilities[each] = self.assigns[each]/total
            
        #Invert to get probability -- parameter binding (prob going from 0 to 1)
        point = 0
        lookup = {}
        for param, prob in probabilities.items():
            lookup[point+prob] = param
            point += prob

        #Pick a random number and get expansion corresponding to probability
        pick = random.random()
        cutoffs = sorted(lookup.keys())
        for cutoff in cutoffs:
            if pick < cutoff:
                return followers[lookup[cutoff]]
            
    def generate(self, generations):
        ''' Generates a compatible string after the provided number of generations'''
        axiom = self.axiom
        while generations > 0:
            tempstring = []
            for element in axiom:
                if element in self.productions:
                    tempstring.extend(self.transform(element))
                else:
                    tempstring.append(element)
            axiom = tempstring
            generations -= 1
        return axiom

    def map(self, genstring):
        ''' Takes in a generated string and returns a string representing
        context instructions'''
        ctxstring = []
        for element in genstring:
            try:
                ctxstring.extend(self.maps[element])
            except KeyError:
                print "Element %s has no mapping" % element
        return ctxstring

class Environment:
    '''Represents the environment in which the Grammars are to created and their
    strings generated. Responsible for handling interactions between Grammars'''

    def __init__(self, builder=None):
        self.builder = builder
        self.grammars = {}

    def populate(self):
        '''Accesses the builder option and gets all the grammar objects '''
        grammarlist = self.builder.build_all()
        newgrammars = []
        for grammar in grammarlist:
            self.grammars[grammar.name] = grammar
            newgrammars.append(grammar.name)
        self.resolve_inherits()
        return newgrammars

    def resolve_inherits(self):
        '''Clones all the grammars which are used as base grammars '''
        for child in self.grammars.values():
            if child.base and not child.resolved:
                self.inherit(grammar, grammars[grammar.base])

                
    def inherit(self, child, base):
        '''Clones a single grammar object and assigns it to a different name '''
        if base.base:
            inherit(base, self.grammars[base.base])
        temp = deepcopy(base)

        if child.axiom == None:
            child.axiom = temp.axiom
        child.productions = temp.productions.update(child.productions)
        child.maps = temp.maps.update(child.maps)
        child.assigns = temp.assigns.update(child.assigns)
        child.resolved = True
        del temp
        
    def add_grammar(self, grammar):
        '''Adds a grammar to the current set of grammars '''
        self.grammars[grammar.name] = grammar

    def list_grammars(self):
        '''Lists all available grammars '''
        msglist = []
        for name, grammar in self.grammars.items():
            msg =  "Grammar " + name
            if grammar.base:
                msg += " derived from " + grammar.base
            msglist.append(msg)
        return msglist
